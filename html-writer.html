<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML-Writer</title>
    <style>
        body {
            height: 100vh;
            margin: 0;
            display: flex;
            flex-direction: column;
        }
        #main {
            display: flex;
            flex-grow: 1;
        }
        #toolbar {
            padding: 5px;
            background: #333;
            color: white;
            overflow-x: auto;
        }
        #toolbar button {
            background: #555;
            color: white;
            border: none;
            padding: 5px 10px;
            margin-right: 5px;
            cursor: pointer;
        }
        #toolbar .info-saved {
            float: right;
        }
        #toolbar button:hover {
            background: #3e787a;
        }
        #editor-container {
            width: 50%;
            height: 100%;
            border-right: 1px solid black;
        }
        #editor {
            width: 100%;
            height: 100%;
        }
        #preview-container {
            height: 100%;
            width: 50%;
            overflow: auto;
            position: relative;
        }
        #preview {
            width: 100%;
            height: 100%;
            border: none;
        }
    </style>
</head>
<body>

<div id="toolbar"></div>
<div id="main">
    <div id="editor-container">
        <div id="editor">loading...</div>
    </div>
    <div id="preview-container">
        <iframe id="preview"></iframe>
    </div>
</div>

<script type="module">
    const dbName = 'htmlWriterDatabase';
    const settingsKey = 'app';

    class Database {
        #db = null;

        constructor() {
            // const me = this;
        }

        init() {
            const me = this;

            return new Promise((resolve, reject) => {

                const request = indexedDB.open(dbName, 3);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    // Settings store (appSettings = whole settings JSON)
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings');
                    }

                    // Document Cache store (id + name per file)
                    if (!db.objectStoreNames.contains('documentCache')) {
                        const store = db.createObjectStore('documentCache', {keyPath: 'id'});
                        store.createIndex('name', 'name', {unique: true});
                    }

                    /**
                     * Scripts store (id + URL + script content)
                     * {
                     *   name: 'ace',
                     *   url: 'https://cdnjs.cloudflare.com/.../ace.js',
                     *   code: '...script contents...'
                     * }
                     */
                    if (!db.objectStoreNames.contains('scripts')) {
                        const store = db.createObjectStore('scripts', {keyPath: 'name'});
                        store.createIndex('url', 'url', {unique: true});
                    }

                    // Templates store (name + html string)
                    if (!db.objectStoreNames.contains('templates')) {
                        db.createObjectStore('templates', {keyPath: 'name'});
                    }
                };

                //upon success, save db instance in runtime
                request.onsuccess = (event) => {
                    me.#db = event.target.result;

                    //add event listener for persistent storage. once per start of tool
                    document.addEventListener("click", me.#requestPersistentStorage, {once: true});

                    resolve(me.#db);
                };

                request.onerror = () => {
                    console.error('DB init failed:', request.error);
                    reject(request.error);
                };

            });
        }

        /**
         * requests persistent storage once upon first page interaction, once.
         * @returns {Promise<void>}
         */
        #requestPersistentStorage = async () => {
            const me = this;
            if (navigator.storage && navigator.storage.persist) {
                const isPersistent = await navigator.storage.persisted();
                if (isPersistent) {
                    console.debug("Persistent storage already granted.");
                    return;
                }

                console.debug("Requesting persistent storage...");
                const granted = await navigator.storage.persist();
                console.debug(`Persistent storage granted: ${granted}`);
            } else {
                console.warn("Persistent storage API not supported.");
            }

            // Remove listener after the first attempt
            document.removeEventListener("click", me.#requestPersistentStorage);
        };

        /**
         * takes a number of names with corresponsing urls and returns the missing or mismatched entries.
         * name missing from db = missing
         * name match, url mismatch = mismatch
         * @param {Object} scriptsObj
         * @returns {Promise<*[]>}
         */
        async getMissingScripts(scriptsObj) {
            const db = this.#db;
            const tx = db.transaction('scripts', 'readonly');
            const store = tx.objectStore('scripts');

            const missingOrMismatched = [];

            for (const [name, url] of Object.entries(scriptsObj)) {
                const request = store.get(name);
                const result = await new Promise(res => {
                    request.onsuccess = () => res(request.result);
                    request.onerror = () => res(null);
                });

                if (!result || result.url !== url) {
                    missingOrMismatched.push(name);
                }
            }

            return missingOrMismatched;
        }

        /**
         * read scripts from db and return them as an array (containing objects)
         * @param keys
         * @returns {Promise<*[]>}
         */
        async getScripts(keys) {
            const db = this.#db;
            const tx = db.transaction('scripts', 'readonly');
            const store = tx.objectStore('scripts');

            const result = [];
            for (const key of keys) {
                const request = store.get(key);
                const script = await new Promise(res => {
                    request.onsuccess = () => res(request.result);
                    request.onerror = () => res(null);
                });
                if (script) {
                    result.push(script);
                }
            }
            return result;
        }

        /**
         * save script in the db with a unique key and url
         * @param name name of the script, unique
         * @param url url origin of the script, should be unique
         * @param code textcontent of the script
         * @returns {Promise<boolean|Event|OfflineAudioCompletionEvent|((result?: PaymentComplete) => Promise<void>)>}
         */
        async saveScript(name, url, code) {
            const me = this;
            const tx = me.#db.transaction('scripts', 'readwrite');
            tx.objectStore('scripts').put({name: name, url: url, code: code});
            return tx.complete;
        }

        /**
         * read settings from db and return them. its a json object
         * @returns {Promise<unknown>}
         */
        async getSettings() {
            const db = this.#db;
            const tx = db.transaction('settings', 'readonly');
            const store = tx.objectStore('settings');
            const request = store.get(settingsKey);

            return await new Promise(res => {
                request.onsuccess = () => res(request.result);
                request.onerror = () => res(null);
            });
        }
    }

    class GithubConnector {
        constructor(db) {

        }
    }

    class Editor {

    }

    class Toolbar {
        #core = {
            beautify: {
                type: 'BUTTON',
                text: 'beautify',
                onclick: this.beautifyCode.bind(this),
                // shortcut: 'Ctrl+Shift+B',    //TODO: later, add customizable shortcuts
            },
            // printPreview: {
            //     type: 'BUTTON',
            //     text: 'print',
            //     onclick: 'me.#toolbar.printPreview()',
            //     // shortcut: 'Ctrl+Shift+P',
            // },
            // saveFile: {
            //     type: 'BUTTON',
            //     text: 'save',
            //     onclick: 'me.#toolbar.saveFile()',
            //     // shortcut: 'Ctrl+Shift+P',
            // },
            // loadFile: {
            //     type: 'BUTTON',
            //     text: 'load',
            //     onclick: 'me.#toolbar.loadFile()',
            //     // shortcut: 'Ctrl+Shift+P',
            // },
        };
        #db;
        #ace;
        #aceBeautify;
        #container;

        constructor(db, ace, aceBeautify) {
            const me = this;
            me.#db = db;
            me.#ace = ace;
            me.#aceBeautify = aceBeautify;
        }

        async init() {
            const me = this;
            me.#container = document.querySelector('#toolbar');

            for (const [key, value] of Object.entries(me.#core)) {
                me.#addToolbarEntry(key, value);
            }

            //TODO: later put more options to configure this
        }

        #addToolbarEntry (key, conf) {
            const entry = document.createElement(conf.type);
            if(conf.type === 'BUTTON') {
                entry.innerText = conf.text;
                entry.addEventListener('click', conf.onclick);
            }
            this.#container.appendChild(entry);

        }

        beautifyCode() {
            console.log('beautify code');
            console.log(this);
        }
    }

    class ScriptLoader {
        #db;
        #coreScripts = {
            ace: 'https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.14/ace.js',
            aceBeautify: 'https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.14/ext-beautify.js'
        };

        constructor(db) {
            this.#db = db;
        }
        async loadCore() {
            const missing = await this.#db.getMissingScripts(this.#coreScripts);

            for (const key of missing) {
                const url = this.#coreScripts[key];
                const code = await this.fetchScript(url);
                await this.#db.saveScript(key, url, code);
            }
        }

        /**
         * calls inject function for all scripts stored in the database
         * @returns {Promise<void>}
         */
        async injectScripts() {
            const scripts = await this.#db.getScripts(Object.keys(this.#coreScripts));
            for (const script of scripts) {
                this.#injectScript(script.code, script.name);
            }
        }

        /**
         * fetches script content and returns it for saving in the db
         * @param url
         * @returns {Promise<string>}
         */
        async fetchScript(url) {    //TODO: make offline check. if offline and need to load script, alert user, if offline and no need to load script, just skip fetching
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to fetch ${url}`);
            }
            return await response.text();
        }

        /**
         * inject single script code into document head
         * @param code
         * @param name
         */
        #injectScript(code, name) {
            const script = document.createElement('script');
            script.type = 'text/javascript';
            script.text = code;
            script.dataset.name = name;
            document.head.appendChild(script);
        }
    }

    /**
     * main program. no other classes should be accessed from the plain script
     */
    class Main {
        #db;
        #settings;
        #scriptLoader;
        #toolbar;
        #ace;
        #aceBeautify;

        /**
         * save the db instance into runtime and initialize it
         * @returns {Promise<unknown>}
         */
        async initDb() {
            const me = this;
            return new Promise(async (resolve) => {
                me.#db = new Database();
                await me.#db.init();
                resolve();
            });
        }

        /**
         * load settings from db and save them into runtime
         * @returns {Promise<unknown>}
         */
        async loadSettings() {
            const me = this;
            return new Promise(async (resolve) => {
                me.#settings = await me.#db.getSettings();
                resolve();
            });
        }

        /**
         * init scriptloader.
         * then fetch-save (if necessary).
         * then load scripts into app
         * @returns {Promise<void>}
         */
        async initScripts() {
            const me = this;
            return new Promise(async (resolve) => {
                me.#scriptLoader = new ScriptLoader(me.#db);
                const l = me.#scriptLoader;
                // await l.init();
                await l.loadCore();
                await l.injectScripts();
                resolve();
            });
        }

        /**
         * initializes and starts toolbar
         * @returns {Promise<void>}
         */
        async initToolbar() {
            const me = this;
            me.#toolbar = new Toolbar(me.#db, me.#ace, me.#aceBeautify);
            await me.#toolbar.init();   //loads toolbar from db config
            // await me.#toolbar.start();  //creates toolbar elements and listeners
        }

        async initAce() {
            this.#ace = ace.edit("editor");
            this.#aceBeautify = ace.require("ace/ext/beautify");
        }
    }

    const main = new Main();
    await main.initDb();
    await main.loadSettings();
    await main.initScripts();
    await main.initAce();
    await main.initToolbar();
    // await main.initAutosave();
    // await main.start();

</script>
<!--
    <script>
        const cacheTime = document.querySelector('.info-saved .value');
        // Initialize Ace Editor
        let htmlContent = "";
        const editor = ace.edit("editor");
        const beautify = ace.require("ace/ext/beautify"); // get reference to extension
        editor.setTheme("ace/theme/monokai");
        editor.session.setMode("ace/mode/html");
        editor.getSession().setOption("wrap", true);

        var previewFrame = document.getElementById("preview");
        var previewDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;

        // Initialize IndexedDB
        // const dbName = "htmlEditorDB";
        const storeName = "editorContent";
        // let db;

        const request = indexedDB.open(dbName, 1);
        request.onerror = function (event) {
            console.error("Error opening IndexedDB:", event);
        };
        request.onsuccess = function (event) {
            db = event.target.result;
            loadContentFromDB();
        };
        request.onupgradeneeded = function (event) {
            db = event.target.result;
            db.createObjectStore(storeName, { keyPath: "id" });
        };

        function updatePreview() {
            const scrollY = previewFrame.contentWindow.scrollY;
            previewDoc.open();
            previewDoc.write(editor.getValue());
            previewDoc.close();

            previewBody = previewDoc.body;
            previewBody.scrollTop = scrollY;
        }

        function printPreview() {
            previewFrame.contentWindow.focus(); // Ensure the iframe is focused
            previewFrame.contentWindow.print(); // Print the iframe content
        }

        function beautifyCode() {
            beautify.beautify(editor.session);
        }

        function saveFile() {
            const content = editor.getValue();
            const blob = new Blob([content], { type: "text/html" });
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = "myfile.html";
            a.click();
            URL.revokeObjectURL(a.href);
        }

        function loadFile() {
            document.getElementById("fileInput").click();
        }

        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                editor.setValue(e.target.result, -1);
                updatePreview();
            };
            reader.readAsText(file);
        }

        function loadContentFromDB() {
            const transaction = db.transaction([storeName], "readonly");
            const store = transaction.objectStore(storeName);
            const getRequest = store.get(1); // ID 1 for the first entry

            getRequest.onsuccess = function (event) {
                const data = event.target.result;
                if (data) {
                    htmlContent = data.content;
                    editor.setValue(htmlContent, -1);
                    updatePreview();
                }
            };
        }

        function cacheContent() {
            const content = editor.getValue();
            const transaction = db.transaction([storeName], "readwrite");
            const store = transaction.objectStore(storeName);

            store.put({ id: 1, content: content });

            const currentDate = new Date();
            cacheTime.innerText = currentDate.toLocaleString();
        }

        setInterval(cacheContent, 10000);

        // Auto-save on page close or when hidden
        window.addEventListener("beforeunload", () => { cacheContent(); });
        document.addEventListener("visibilitychange", () => {
            if (document.hidden) {
                cacheContent();
            }
        });

        editor.session.on("change", function () {
            updatePreview();
        });

        updatePreview();
    </script>
     -->
</body>
</html>
